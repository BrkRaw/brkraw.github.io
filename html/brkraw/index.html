<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>brkraw API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>brkraw</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .lib import *

__version__ = &#39;0.3.3rc0&#39;
__all__ = [&#39;BrukerLoader&#39;, &#39;__version__&#39;]


def load(path):
    return BrukerLoader(path)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="brkraw.lib" href="lib/index.html">brkraw.lib</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="brkraw.scripts" href="scripts/index.html">brkraw.scripts</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="brkraw.ui" href="ui/index.html">brkraw.ui</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="brkraw.BrukerLoader"><code class="flex name class">
<span>class <span class="ident">BrukerLoader</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>The front-end handler for Bruker PvDataset</p>
<p>This class is designed to use for handle PvDataset and optimized for PV 6.0.1, but
also provide backward compatibility with PV 5.1. This class can import naive
PvDataset with directory as well as compressed dataset by zip and Paravision 6.0.1
(<em>.zip and </em>.PvDatasets).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>num_scans</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of scan objects on the loaded dataset.</dd>
<dt><strong><code>num_recos</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of reco objects on the loaded dataset.</dd>
<dt><strong><code>is_pvdataset</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return True if imported path is PvDataset, else False</dd>
</dl>
<h2 id="methods">Methods</h2>
<ul>
<li>
<p>get method for data object
get_dataobj(scan_id, reco_id)
return dataobj without reshape (numpy.array)
get_fid(scan_id)
return binary fid object
get_niftiobj(scan_id, reco_id)
return nibabel's NifTi1Image object</p>
</li>
<li>
<p>get method for parameter objects
get_acqp(scan_id)
return acqp parameter object
get_method(scan_id)
return method parameter object
get_visu_pars(scan_id, reco_id)
return visu_pars parameter object</p>
</li>
<li>
<p>get method for image parameters
get_matrix_size(scan_id, reco_id)
return matrix shape to reshape dataobj
get_affine(scan_id, reco_id)
return affine transform matrix
get_bdata(scan_id, reco_id)
return bmat, bvec, bval as string
get_scan_time(visu_pars=None)
return dictionary contains the datetime object for session initiate time
if visu_pars parameter object is given, it will contains scan start time</p>
</li>
<li>
<p>method to generate files
save_nifti(scan_id, reco_id, filename, dir='./', ext='nii.gz')
generate NifTi1 file
save_bdata(scan_id, filename, dir='./')
generate FSL's Bdata files for DTI image processing
save_json(scan_id, reco_id, filename, dir='./')
generate JSON with given filename for BIDS MRI parameters</p>
</li>
<li>
<p>method to print meta information
print_bids(scan_id, reco_id, fobj=None)
print out BIDS MRI parameters defined at reference.py
if fileobject is given, it will be written in file instead of stdout
info(fobj=None)
print out the PvDataset major parameters
if fileobject is given, it will be written in file instead of stdout</p>
</li>
</ul>
<p>class method to initiate object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path of PvDataset.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrukerLoader():
    &#34;&#34;&#34; The front-end handler for Bruker PvDataset

    This class is designed to use for handle PvDataset and optimized for PV 6.0.1, but
    also provide backward compatibility with PV 5.1. This class can import naive
    PvDataset with directory as well as compressed dataset by zip and Paravision 6.0.1
    (*.zip and *.PvDatasets).

    Attributes:
        num_scans (int): The number of scan objects on the loaded dataset.
        num_recos (int): The number of reco objects on the loaded dataset.
        is_pvdataset (bool): Return True if imported path is PvDataset, else False

    Methods:
        - get method for data object
        get_dataobj(scan_id, reco_id)
            return dataobj without reshape (numpy.array)
        get_fid(scan_id)
            return binary fid object
        get_niftiobj(scan_id, reco_id)
            return nibabel&#39;s NifTi1Image object

        - get method for parameter objects
        get_acqp(scan_id)
            return acqp parameter object
        get_method(scan_id)
            return method parameter object
        get_visu_pars(scan_id, reco_id)
            return visu_pars parameter object

        - get method for image parameters
        get_matrix_size(scan_id, reco_id)
            return matrix shape to reshape dataobj
        get_affine(scan_id, reco_id)
            return affine transform matrix
        get_bdata(scan_id, reco_id)
            return bmat, bvec, bval as string
        get_scan_time(visu_pars=None)
            return dictionary contains the datetime object for session initiate time
            if visu_pars parameter object is given, it will contains scan start time

        - method to generate files
        save_nifti(scan_id, reco_id, filename, dir=&#39;./&#39;, ext=&#39;nii.gz&#39;)
            generate NifTi1 file
        save_bdata(scan_id, filename, dir=&#39;./&#39;)
            generate FSL&#39;s Bdata files for DTI image processing
        save_json(scan_id, reco_id, filename, dir=&#39;./&#39;)
            generate JSON with given filename for BIDS MRI parameters

        - method to print meta information
        print_bids(scan_id, reco_id, fobj=None)
            print out BIDS MRI parameters defined at reference.py
            if fileobject is given, it will be written in file instead of stdout
        info(fobj=None)
            print out the PvDataset major parameters
            if fileobject is given, it will be written in file instead of stdout
    &#34;&#34;&#34;
    def __init__(self, path):
        &#34;&#34;&#34; class method to initiate object.
        Args:
            path (str): Path of PvDataset.
        &#34;&#34;&#34;
        self._pvobj = load(path)

        if (self.num_scans &gt; 0) and (self._subject != None):
            self._is_pvdataset = True
        else:
            self._is_pvdataset = False

    @property
    def pvobj(self):
        return self._pvobj

    @property
    def num_scans(self):
        return len(self._pvobj._fid.keys())

    @property
    def num_recos(self):
        return sum([len(r) for r in self._avail.values()])

    @property
    def is_pvdataset(self):
        return self._is_pvdataset

    def close(self):
        self._pvobj.close()
        self._pvobj = None

    def get_affine(self, scan_id, reco_id):
        visu_pars = self._get_visu_pars(scan_id, reco_id)
        method = self._method[scan_id]
        return self._get_affine(visu_pars, method)

    def _get_dataobj(self, scan_id, reco_id):
        dataobj = self._pvobj.get_dataobj(scan_id, reco_id)
        return dataobj

    def _get_dataslp(self, visu_pars):
        &#34;&#34;&#34; Return data slope and offset for value correction
        Args:
            visu_pars:

        Returns:
            data_slp
            data_off
        &#34;&#34;&#34;
        data_slp = get_value(visu_pars, &#39;VisuCoreDataSlope&#39;)
        data_off = get_value(visu_pars, &#39;VisuCoreDataOffs&#39;)
        if isinstance(data_slp, list):
            data_slp = data_slp[0] if is_all_element_same(data_slp) else data_slp
        if isinstance(data_off, list):
            data_off = data_off[0] if is_all_element_same(data_off) else data_off
        return data_slp, data_off

    def get_dataobj(self, scan_id, reco_id, slope=True):
        &#34;&#34;&#34; Return dataobj that has 3D(spatial) + extra frame
        Args:
            scan_id: scan id
            reco_id: reco id
            slope: if True correct slope
        Returns:
            dataobj
        &#34;&#34;&#34;
        visu_pars   = self._get_visu_pars(scan_id, reco_id)
        dim         = self._get_dim_info(visu_pars)[0]
        fg_info     = self._get_frame_group_info(visu_pars)
        matrix_size = self.get_matrix_size(scan_id, reco_id)
        dataobj = self._get_dataobj(scan_id, reco_id)
        group_id    = fg_info[&#39;group_id&#39;]

        if slope:
            data_slp, data_off = self._get_dataslp(visu_pars)
            f = fg_info[&#39;frame_size&#39;]
            if isinstance(data_slp, list):
                if f != len(data_slp):
                    raise UnexpectedError(message=&#39;data_slp mismatch;&#39;
                                                  f&#39;{ISSUE_REPORT}&#39;)
                else:
                    if dim == 2:
                        x, y = matrix_size[:2]
                        _dataobj = dataobj.reshape([f, x * y]).T
                    elif dim == 3:
                        x, y, z = matrix_size[:3]
                        _dataobj = dataobj.reshape([f, x * y * z]).T
                    else:
                        raise UnexpectedError(message=&#39;Unexpected frame shape on DTI image;&#39;
                                                      f&#39;{ISSUE_REPORT}&#39;)
                dataobj = (_dataobj * data_slp + data_off).T
            else:
                dataobj = dataobj * data_slp + data_off

        dataobj = dataobj.reshape(matrix_size[::-1]).T

        def swap_slice_axis(group_id_, dataobj_):
            &#34;&#34;&#34; swap slice axis to third axis &#34;&#34;&#34;
            slice_code = &#39;FG_SLICE&#39;
            if slice_code not in group_id_:
                pass
            else:
                slice_axis_ = group_id_.index(slice_code) + 2
                dataobj_ = np.swapaxes(dataobj_, 2, slice_axis_)
            return dataobj_

        if fg_info[&#39;frame_type&#39;] is not None:
            if group_id[0] == &#39;FG_SLICE&#39;:
                pass

            elif group_id[0] == &#39;FG_ECHO&#39;:  # multi-echo
                if self.is_multi_echo(scan_id, reco_id):
                    # push echo to last axis for BIDS
                    if &#39;FG_SLICE&#39; not in group_id:
                        dataobj = np.swapaxes(dataobj, dim, -1)
                    else:
                        slice_axis = group_id.index(&#39;FG_SLICE&#39;) + 2
                        dataobj = np.swapaxes(dataobj, slice_axis, -1)
                        dataobj = np.swapaxes(dataobj, 2, -1)

            elif group_id[0] == &#39;FG_DIFFUSION&#39;:
                dataobj = swap_slice_axis(group_id, dataobj)

            elif group_id[0] == &#39;FG_DTI&#39;:   # reconstructed
                dataobj = swap_slice_axis(group_id, dataobj)

            elif group_id[0] == &#39;FG_MOVIE&#39;:
                dataobj = swap_slice_axis(group_id, dataobj)

            else:
                raise UnexpectedError(message=&#39;Unexpected frame group combination;&#39;
                                              f&#39;{ISSUE_REPORT}&#39;)
        return dataobj

    def get_fid(self, scan_id):
        return self._pvobj.get_fid(scan_id)

    @property
    def get_visu_pars(self):
        return self._get_visu_pars

    def get_method(self, scan_id):
        return self._method[scan_id]

    def get_acqp(self, scan_id):
        return self._acqp[scan_id]

    def get_bdata(self, scan_id):
        method = self.get_method(scan_id)
        return self._get_bdata(method)

    def get_matrix_size(self, scan_id, reco_id):
        visu_pars = self._get_visu_pars(scan_id, reco_id)
        dataobj = self._get_dataobj(scan_id, reco_id)
        return self._get_matrix_size(visu_pars, dataobj)

    def is_multi_echo(self, scan_id, reco_id):
        visu_pars = self._get_visu_pars(scan_id, reco_id)
        fg_info = self._get_frame_group_info(visu_pars)
        group_id = fg_info[&#39;group_id&#39;]
        if &#39;FG_ECHO&#39; in group_id and &#39;FieldMap&#39; not in fg_info[&#39;group_comment&#39;]:  #FieldMap will be treated different
            return fg_info[&#39;matrix_shape&#39;][group_id.index(&#39;FG_ECHO&#39;)]  # return number of echos
        else:
            return False

    # methods to dump data into file object
    ## - NifTi1
    def get_niftiobj(self, scan_id, reco_id, crop=None, slope=False):
        &#34;&#34;&#34; return nibabel nifti object
        Args:
            scan_id:
            reco_id:
            crop:   frame crop range
            slope:  if True, slope correction, else, header update
        Returns:
            nibabel.Nifti1Image
        &#34;&#34;&#34;
        from nibabel import Nifti1Image
        visu_pars = self._get_visu_pars(scan_id, reco_id)
        method = self._method[scan_id]
        affine = self._get_affine(visu_pars, method)
        group_id = self._get_frame_group_info(visu_pars)[&#39;group_id&#39;]
        if &#39;FG_DTI&#39; in group_id:
            # DTI dataset has vector slope
            slope = True
        imgobj = self.get_dataobj(scan_id, reco_id, slope=slope)
        # dataobj = self._get_dataobj(scan_id, reco_id)
        # shape = self._get_matrix_size(visu_pars, dataobj)
        # imgobj = dataobj.reshape(shape[::-1]).T

        if isinstance(affine, list):
            parser = []
            slice_info = self._get_slice_info(visu_pars)
            num_slice_packs = slice_info[&#39;num_slice_packs&#39;]

            for spack_idx in range(num_slice_packs):
                num_slices_each_pack = slice_info[&#39;num_slices_each_pack&#39;]
                start = int(spack_idx * num_slices_each_pack[spack_idx])
                end = start + num_slices_each_pack[spack_idx]
                seg_imgobj = imgobj[..., start:end]
                niiobj = Nifti1Image(seg_imgobj, np.round(affine[spack_idx], decimals=3))
                niiobj = self._set_nifti_header(niiobj, visu_pars, method, slope=slope)
                parser.append(niiobj)
            return parser
        affine = np.round(affine, decimals=3)
        if self.is_multi_echo(scan_id, reco_id):
            # multi-echo image must be splitted
            parser = []
            for e in range(imgobj.shape[-1]):
                imgobj_ = imgobj[..., e]
                if len(imgobj_.shape) &gt; 4:
                    x, y, z = imgobj_.shape[:3]
                    f = multiply_all(imgobj_.shape[3:])
                    # all converted nifti must be 4D
                    imgobj_ = imgobj_.reshape([x, y, z, f])
                if crop is not None:
                    if crop[0] is None:
                        niiobj_ = Nifti1Image(imgobj_[..., :crop[1]], affine)
                    elif crop[1] is None:
                        niiobj_ = Nifti1Image(imgobj_[..., crop[0]:], affine)
                    else:
                        niiobj_ = Nifti1Image(imgobj_[..., crop[0]:crop[1]], affine)
                else:
                    niiobj_ = Nifti1Image(imgobj_, affine)
                niiobj_ = self._set_nifti_header(niiobj_, visu_pars, method, slope=slope)
                parser.append(niiobj_)
            return parser
        else:
            if len(imgobj.shape) &gt; 4:
                x, y, z = imgobj.shape[:3]
                f = multiply_all(imgobj.shape[3:])
                # all converted nifti must be 4D
                imgobj = imgobj.reshape([x, y, z, f])
        if crop is not None:
            if crop[0] is None:
                niiobj = Nifti1Image(imgobj[..., :crop[1]], affine)
            elif crop[1] is None:
                niiobj = Nifti1Image(imgobj[..., crop[0]:], affine)
            else:
                niiobj = Nifti1Image(imgobj[..., crop[0]:crop[1]], affine)
        else:
            niiobj = Nifti1Image(imgobj, affine)
        niiobj = self._set_nifti_header(niiobj, visu_pars, method, slope=slope)
        return niiobj

    def get_sitkimg(self, scan_id, reco_id, slope=True, is_vector=False):
        &#34;&#34;&#34; return SimpleITK image obejct instead Nibabel NIFTI obj&#34;&#34;&#34;
        import SimpleITK as sitk

        visu_pars = self._get_visu_pars(scan_id, reco_id)
        method = self._method[scan_id]
        res = self._get_spatial_info(visu_pars)[&#39;spatial_resol&#39;]
        dataobj = self.get_dataobj(scan_id, reco_id, slope=slope)
        affine = self._get_affine(visu_pars, method)

        if isinstance(affine, list):
            parser = []
            slice_info = self._get_slice_info(visu_pars)
            num_slice_packs = slice_info[&#39;num_slice_packs&#39;]
            for spack_idx in range(num_slice_packs):
                num_slices_each_pack = slice_info[&#39;num_slices_each_pack&#39;]
                start = int(spack_idx * num_slices_each_pack[spack_idx])
                end = start + num_slices_each_pack[spack_idx]
                seg_imgobj = dataobj[..., start:end]
                sitkobj = sitk.GetImageFromArray(seg_imgobj.T)
                sitkaff = np.matmul(np.diag([-1, -1, 1, 1]), affine[spack_idx])
                sitkdir, sitkorg = to_matvec(sitkaff)
                sitkdir = sitkdir.dot(np.linalg.inv(np.diag(res[spack_idx])))
                sitkobj.SetDirection(sitkdir.flatten().tolist())
                sitkobj.SetOrigin(sitkorg)
                sitkobj.SetSpacing(res[spack_idx])
                parser.append(sitkobj)
            return parser

        affine = np.matmul(np.diag([-1, -1, 1, 1]), affine)  # RAS to LPS
        direction_, origin_ = to_matvec(affine)
        direction_ = direction_.dot(np.linalg.inv(np.diag(res[0])))
        imgobj = sitk.GetImageFromArray(dataobj.T, isVector=is_vector)

        if len(dataobj.shape) &gt; 3:
            res = [list(res[0]) + [self._get_temp_info(visu_pars)[&#39;temporal_resol&#39;]]]
            direction = np.eye(4)
            direction[:3, :3] = direction_
            direction = direction.flatten()
            origin = np.zeros([4])
            origin[:3] = origin_
        else:
            direction = direction_
            origin = origin_
        imgobj.SetDirection(direction.flatten().tolist())
        imgobj.SetOrigin(origin)
        imgobj.SetSpacing(res[0])
        # header update
        imgobj = self._set_dicom_header(imgobj, visu_pars, method, slope)
        return imgobj

    def _set_dicom_header(self, sitk_img, visu_pars, method, slope):
        &#34;&#34;&#34; TODO: need to update sitk header (DICOM format) &#34;&#34;&#34;
        return sitk_img

    def save_sitk(self, io_type=None):
        &#34;&#34;&#34; TODO: mha, nrrd format with header &#34;&#34;&#34;
        pass

    @property
    def save_as(self):
        return self.save_nifti

    def save_nifti(self, scan_id, reco_id, filename, dir=&#39;./&#39;, ext=&#39;nii.gz&#39;,
                crop=None):
        niiobj = self.get_niftiobj(scan_id, reco_id, crop=crop)
        if isinstance(niiobj, list):
            for i, nii in enumerate(niiobj):
                output_path = os.path.join(dir,
                                           &#39;{}-{}.{}&#39;.format(filename,
                                                             str(i+1).zfill(2), ext))
                nii.to_filename(output_path)
        else:
            output_path = os.path.join(dir, &#39;{}.{}&#39;.format(filename, ext))
            niiobj.to_filename(output_path)

    # - FSL bval, bvec, and bmat
    def save_bdata(self, scan_id, filename, dir=&#39;./&#39;):
        method = self._method[scan_id]
        bval, bvec, bmat = self._get_bdata(method)
        output_path = os.path.join(dir, filename)

        with open(&#39;{}.bval&#39;.format(output_path), &#39;w&#39;) as bval_fobj:
            for item in bval:
                bval_fobj.write(&#34;%f &#34; % item)
            bval_fobj.write(&#34;\n&#34;)

        with open(&#39;{}.bvec&#39;.format(output_path), &#39;w&#39;) as bvec_fobj:
            for row in bvec:
                for item in row:
                    bvec_fobj.write(&#34;%f &#34; % item)
                bvec_fobj.write(&#34;\n&#34;)

        with open(&#39;{}.bmat&#39;.format(output_path), &#39;w&#39;) as bmat_fobj:
            for row in bmat:
                for item in row.flatten():
                    bmat_fobj.write(&#34;%s &#34; % item)
                bmat_fobj.write(&#34;\n&#34;)

    # BIDS JSON
    def _parse_json(self, scan_id, reco_id, metadata=None):
        acqp = self._acqp[scan_id]
        method = self._method[scan_id]
        visu_pars = self._get_visu_pars(scan_id, reco_id)

        json_obj = dict()
        encdir_dic = {0: &#39;i&#39;, 1: &#39;j&#39;, 2: &#39;k&#39;}

        if metadata is None:
            metadata = COMMON_META_REF.copy()
        for k, v in metadata.items():
            val = meta_get_value(v, acqp, method, visu_pars)
            if k in [&#39;PhaseEncodingDirection&#39;, &#39;SliceEncodingDirection&#39;]:
                if val is not None:
                    if isinstance(val, int):
                        val = encdir_dic[val]
                    else:
                        if isinstance(val, list):
                            if is_all_element_same(val):
                                val = val[0]
                            else:
                                raise UnexpectedError(&#39;Unexpected phase encoding direction in PV5.1.&#39;)
                        elif isinstance(val, str):
                            pass
                        else:
                            raise UnexpectedError(&#39;Unexpected phase encoding direction in PV5.1.&#39;)

                        encdirs = encdir_code_converter(val)
                        if &#39;phase_enc&#39; in encdirs:
                            pe_idx = encdirs.index(&#39;phase_enc&#39;)
                            val = encdir_dic[pe_idx]
                        else:
                            val = None

            if isinstance(val, np.ndarray):
                val = val.tolist()
            json_obj[k] = val
        return json_obj

    def save_json(self, scan_id, reco_id, filename, dir=&#39;./&#39;, metadata=None, condition=None):
        json_obj = self._parse_json(scan_id, reco_id, metadata)
        if condition is not None:
            code, idx = condition
            if code == &#39;me&#39;:    # multi-echo
                if &#39;EchoTime&#39; in json_obj.keys():
                    te = json_obj[&#39;EchoTime&#39;]
                    if isinstance(te, list):
                        json_obj[&#39;EchoTime&#39;] = te[idx]
                    else:
                        raise InvalidApproach(&#39;SingleTE data&#39;)
            elif code == &#39;fm&#39;:
                visu_pars = self._get_visu_pars(scan_id, reco_id)
                json_obj[&#39;Units&#39;] = get_value(visu_pars, &#39;VisuCoreDataUnits&#39;)[0]
                json_obj[&#39;IntendFor&#39;] = [&#34;func/*_bold.nii.gz&#34;]
            else:
                raise InvalidApproach(&#39;Invalid datatype code for json creation&#39;)

        # remove all null fields
        for k, v in json_obj.items():
            if v is None:
                json_obj[k] = &#39;Value was not specified&#39;
        with open(os.path.join(dir, &#39;{}.json&#39;.format(filename)), &#39;w&#39;) as f:
            import json
            json.dump(json_obj, f, indent=4)

    def get_scan_time(self, visu_pars=None):
        import datetime as dt
        subject_date = get_value(self._subject, &#39;SUBJECT_date&#39;)
        subject_date = subject_date[0] if isinstance(subject_date, list) else subject_date
        pattern_1 = r&#39;(\d{2}:\d{2}:\d{2})\s+(\d+\s\w+\s\d{4})&#39;
        pattern_2 = r&#39;(\d{4}-\d{2}-\d{2})[T](\d{2}:\d{2}:\d{2})&#39;
        if re.match(pattern_1, subject_date):
            # start time
            start_time = dt.time(*map(int, re.sub(pattern_1, r&#39;\1&#39;, subject_date).split(&#39;:&#39;)))
            # date
            date = dt.datetime.strptime(re.sub(pattern_1, r&#39;\2&#39;, subject_date), &#39;%d %b %Y&#39;).date()
            # end time
            if visu_pars is not None:
                last_scan_time = get_value(visu_pars, &#39;VisuAcqDate&#39;)
                last_scan_time = dt.time(*map(int, re.sub(pattern_1, r&#39;\1&#39;, last_scan_time).split(&#39;:&#39;)))
                acq_time = get_value(visu_pars, &#39;VisuAcqScanTime&#39;) / 1000.0
                time_delta = dt.timedelta(0, acq_time)
                scan_time = (dt.datetime.combine(date, last_scan_time) + time_delta).time()
                return dict(date=date,
                            start_time=start_time,
                            scan_time=scan_time)
        elif re.match(pattern_2, subject_date):
            # start time
            # subject_date = get_value(self._subject, &#39;SUBJECT_date&#39;)[0]
            start_time = dt.time(*map(int, re.sub(pattern_2, r&#39;\2&#39;, subject_date).split(&#39;:&#39;)))
            # date
            date = dt.date(*map(int, re.sub(pattern_2, r&#39;\1&#39;, subject_date).split(&#39;-&#39;)))

            # end date
            if visu_pars is not None:
                scan_time = get_value(visu_pars, &#39;VisuCreationDate&#39;)[0]
                scan_time = dt.time(*map(int, re.sub(pattern_2, r&#39;\2&#39;, scan_time).split(&#39;:&#39;)))
                return dict(date=date,
                            start_time=start_time,
                            scan_time=scan_time)
        else:
            raise Exception(ERROR_MESSAGES[&#39;NotIntegrated&#39;])

        return dict(date=date,
                    start_time=start_time)

    # printing functions / help documents
    def print_bids(self, scan_id, reco_id, fobj=None, metadata=None):
        if fobj == None:
            import sys
            fobj = sys.stdout
        json_obj = self._parse_json(scan_id, reco_id, metadata)
        for k, val in json_obj.items():
            n_tap = int(5 - int(len(k) / 8))
            if len(k) % 8 &gt;= 7:
                n_tap -= 1
            tap = &#39;&#39;.join([&#39;\t&#39;] * n_tap)
            print(&#39;{}:{}{}&#39;.format(k, tap, val), file=fobj)

    def info(self, io_handler=None):
        &#34;&#34;&#34; Prints out the information of the internal contents in Bruker raw data
        Args:
            io_handler: IO handler where to print out
        &#34;&#34;&#34;
        if io_handler == None:
            import sys
            io_handler = sys.stdout

        pvobj = self._pvobj
        user_account = pvobj.user_account
        subj_id = pvobj.subj_id
        study_id = pvobj.study_id
        session_id = pvobj.session_id
        user_name = pvobj.user_name
        subj_entry = pvobj.subj_entry
        subj_pose = pvobj.subj_pose
        subj_sex = pvobj.subj_sex
        subj_type = pvobj.subj_type
        subj_weight = pvobj.subj_weight
        subj_dob = pvobj.subj_dob

        lines = []
        for i, (scan_id, recos) in enumerate(self._avail.items()):
            for j, reco_id in enumerate(recos):
                visu_pars = self._get_visu_pars(scan_id, reco_id)
                if i == 0:
                    sw_version = get_value(visu_pars, &#39;VisuCreatorVersion&#39;)

                    title = &#39;Paravision {}&#39;.format(sw_version)
                    lines.append(title)
                    lines.append(&#39;-&#39; * len(title))

                    try:
                        datetime = self.get_scan_time()
                    except:
                        datetime = dict(date=&#39;None&#39;)
                        # raise Exception(&#39;Empty dataset...&#39;)
                    lines.append(&#39;UserAccount:\t{}&#39;.format(user_account))
                    lines.append(&#39;Date:\t\t{}&#39;.format(datetime[&#39;date&#39;]))
                    lines.append(&#39;Researcher:\t{}&#39;.format(user_name))
                    lines.append(&#39;Subject ID:\t{}&#39;.format(subj_id))
                    lines.append(&#39;Session ID:\t{}&#39;.format(session_id))
                    lines.append(&#39;Study ID:\t{}&#39;.format(study_id))
                    lines.append(&#39;Date of Birth:\t{}&#39;.format(subj_dob))
                    lines.append(&#39;Sex:\t\t{}&#39;.format(subj_sex))
                    lines.append(&#39;Weight:\t\t{} kg&#39;.format(subj_weight))
                    lines.append(&#39;Subject Type:\t{}&#39;.format(subj_type))
                    lines.append(&#39;Position:\t{}\t\tEntry:\t{}&#39;.format(subj_pose, subj_entry))

                    lines.append(&#39;\n[ScanID]\tSequence::Protocol::[Parameters]&#39;)
                # try:
                tr = get_value(visu_pars, &#39;VisuAcqRepetitionTime&#39;)
                tr = &#39;,&#39;.join(map(str, tr)) if isinstance(tr, list) else tr
                te = get_value(visu_pars, &#39;VisuAcqEchoTime&#39;)
                te = 0 if te is None else te
                te = &#39;,&#39;.join(map(str, te)) if isinstance(te, list) else te
                pixel_bw = get_value(visu_pars, &#39;VisuAcqPixelBandwidth&#39;)
                flip_angle = get_value(visu_pars, &#39;VisuAcqFlipAngle&#39;)
                param_values = [tr, te, pixel_bw, flip_angle]
                for k, v in enumerate(param_values):
                    if v is None:
                        param_values[k] = &#39;&#39;
                    if isinstance(v, float):
                        param_values[k] = &#39;{0:.2f}&#39;.format(v)
                if j == 0:
                    params = &#34;[ TR: {0} ms, TE: {1} ms, pixelBW: {2} Hz, FlipAngle: {3} degree]&#34;.format(
                        *param_values)
                    protocol_name = get_value(visu_pars, &#39;VisuAcquisitionProtocol&#39;)
                    sequence_name = get_value(visu_pars, &#39;VisuAcqSequenceName&#39;)
                    lines.append(&#39;[{}]\t{}::{}::\n\t{}&#39;.format(str(scan_id).zfill(3),
                                                               sequence_name,
                                                               protocol_name,
                                                               params))

                dim, cls = self._get_dim_info(visu_pars)
                if cls == &#39;spatial_only&#39;:
                    size = self._get_matrix_size(visu_pars)
                    size = &#39; x &#39;.join(map(str, size))
                    spatial_info = self._get_spatial_info(visu_pars)
                    temp_info = self._get_temp_info(visu_pars)
                    s_resol = spatial_info[&#39;spatial_resol&#39;]
                    fov_size = spatial_info[&#39;fov_size&#39;]
                    fov_size = &#39; x &#39;.join(map(str, fov_size))
                    s_unit = spatial_info[&#39;unit&#39;]
                    t_resol = &#39;{0:.3f}&#39;.format(temp_info[&#39;temporal_resol&#39;])
                    t_unit = temp_info[&#39;unit&#39;]
                    s_resol = list(s_resol[0]) if is_all_element_same(s_resol) else s_resol
                    s_resol = &#39; x &#39;.join([&#39;{0:.3f}&#39;.format(r) for r in s_resol])

                    lines.append(&#39;    [{}] dim: {}D, matrix_size: {}, fov_size: {} (unit:mm)\n&#39;
                                 &#39;         spatial_resol: {} (unit:{}), temporal_resol: {} (unit:{})&#39;.format(
                        str(reco_id).zfill(2), dim, size,
                        fov_size,
                        s_resol, s_unit,
                        t_resol, t_unit))
                else:
                    lines.append(f&#39;    [{str(reco_id).zfill(2)}] dim: {dim}, {cls}&#39;)
                # except Exception as e:
                #     print(e)
                #     print(f&#39;Issue found at {scan_id}&#39;)
        lines.append(&#39;\n&#39;)
        print(&#39;\n&#39;.join(lines), file=io_handler)

    # method to parse information of each scan
    # methods of protocol specific

    def _set_nifti_header(self, niiobj, visu_pars, method, slope):
        slice_info = self._get_slice_info(visu_pars)
        niiobj.header.default_x_flip = False
        temporal_resol = self._get_temp_info(visu_pars)[&#39;temporal_resol&#39;]
        temporal_resol = float(temporal_resol) / 1000
        slice_order = get_value(method, &#39;PVM_ObjOrderScheme&#39;)
        acq_method = get_value(method, &#39;Method&#39;)

        data_slp, data_off = self._get_dataslp(visu_pars)

        if re.search(&#39;epi&#39;, acq_method, re.IGNORECASE) and not \
                re.search(&#39;dti&#39;, acq_method, re.IGNORECASE):

            niiobj.header.set_xyzt_units(xyz=2, t=8)
            niiobj.header[&#39;pixdim&#39;][4] = temporal_resol
            niiobj.header.set_dim_info(slice=2)
            num_slices = slice_info[&#39;num_slices_each_pack&#39;][0]
            niiobj.header[&#39;slice_duration&#39;] = temporal_resol / num_slices

            if slice_order == &#39;User_defined_slice_scheme&#39;:
                niiobj.header[&#39;slice_code&#39;] = 0
            elif slice_order == &#39;Sequential&#39;:
                niiobj.header[&#39;slice_code&#39;] = 1
            elif slice_order == &#39;Reverse_sequential&#39;:
                niiobj.header[&#39;slice_code&#39;] = 2
            elif slice_order == &#39;Interlaced&#39;:
                niiobj.header[&#39;slice_code&#39;] = 3
            elif slice_order == &#39;Reverse_interlacesd&#39;:
                niiobj.header[&#39;slice_code&#39;] = 4
            elif slice_order == &#39;Angiopraphy&#39;:
                niiobj.header[&#39;slice_code&#39;] = 0
            else:
                raise Exception(ERROR_MESSAGES[&#39;NotIntegrated&#39;])
            niiobj.header[&#39;slice_start&#39;] = 0
            niiobj.header[&#39;slice_end&#39;] = num_slices - 1
        else:
            niiobj.header.set_xyzt_units(&#39;mm&#39;)
        niiobj.header[&#39;qform_code&#39;] = 1
        niiobj.header[&#39;sform_code&#39;] = 0
        if not slope:
            if isinstance(data_slp, list):
                raise InvalidApproach(&#39;Invalid slope size;&#39;
                                      &#39;The vector type scl_slope cannot be set in nifti header.&#39;)
            else:
                niiobj.header[&#39;scl_slope&#39;] = data_slp
                niiobj.header[&#39;scl_inter&#39;] = data_off
        return niiobj

    # EPI
    def _get_temp_info(self, visu_pars):
        &#34;&#34;&#34;return temporal resolution for each volume of image&#34;&#34;&#34;
        total_time = get_value(visu_pars, &#39;VisuAcqScanTime&#39;)
        fg_info = self._get_frame_group_info(visu_pars)
        parser = []
        if fg_info[&#39;frame_type&#39;] is not None:
            for id, fg in enumerate(fg_info[&#39;group_id&#39;]):
                if not re.search(&#39;slice&#39;, fg, re.IGNORECASE):
                    parser.append(fg_info[&#39;matrix_shape&#39;][id])
        frame_size = multiply_all(parser) if len(parser) &gt; 0 else 1
        if total_time is None:  # derived reco data
            total_time = 0
        return dict(temporal_resol=(total_time / frame_size),
                    num_frames=frame_size,
                    unit=&#39;msec&#39;)

    # DTI
    @staticmethod
    def _get_bdata(method):
        bval = get_value(method, &#39;PVM_DwEffBval&#39;)
        bvec = get_value(method, &#39;PVM_DwGradVec&#39;)
        bmat = get_value(method, &#39;PVM_DwBMat&#39;)
        return bval, bvec, bmat

    # Generals
    @staticmethod
    def _get_gradient_encoding_info(visu_pars):
        version = get_value(visu_pars, &#39;VisuVersion&#39;)

        if version == 1:  # case PV 5.1, prepare compatible form of variable
            phase_enc = get_value(visu_pars, &#39;VisuAcqImagePhaseEncDir&#39;)
            phase_enc = phase_enc[0] if is_all_element_same(phase_enc) else phase_enc
            if isinstance(phase_enc, list) and len(phase_enc) &gt; 1:
                encoding_axis = []
                for d in phase_enc:
                    encoding_axis.append(encdir_code_converter(d))
            else:
                encoding_axis = encdir_code_converter(phase_enc)
        else:  # case PV 6.0.1
            encoding_axis = get_value(visu_pars, &#39;VisuAcqGradEncoding&#39;)
        return encoding_axis

    def _get_dim_info(self, visu_pars):
        &#34;&#34;&#34;check if the frame contains only spatial components&#34;&#34;&#34;
        dim      = get_value(visu_pars, &#39;VisuCoreDim&#39;)
        dim_desc = get_value(visu_pars, &#39;VisuCoreDimDesc&#39;)

        if not all(map(lambda x: x == &#39;spatial&#39;, dim_desc)):
            if &#39;spectroscopic&#39; in dim_desc:
                return dim, &#39;contain_spectroscopic&#39;  # spectroscopic data
            elif &#39;temporal&#39; in dim_desc:
                return dim, &#39;contain_temporal&#39;  # unexpected data
        else:
            return dim, &#39;spatial_only&#39;

    def _get_spatial_info(self, visu_pars):
        dim, dim_type = self._get_dim_info(visu_pars)
        if dim_type != &#39;spatial_only&#39;:
            if dim != 1:
                raise Exception(ERROR_MESSAGES[&#39;DimType&#39;])
            else:
                # experimental approaches
                matrix_size = get_value(visu_pars, &#39;VisuCoreSize&#39;)
                fov_size    = get_value(visu_pars, &#39;VisuCoreExtent&#39;)
                voxel_resol = np.divide(fov_size, matrix_size).tolist()
            return dict(spatial_resol = [voxel_resol],
                        matrix_size = [matrix_size],
                        fov_size    = fov_size,
                        unit        = &#39;mm&#39;,
                        )
        else:
            matrix_size = get_value(visu_pars, &#39;VisuCoreSize&#39;)
            fov_size    = get_value(visu_pars, &#39;VisuCoreExtent&#39;)
            voxel_resol = np.divide(fov_size, matrix_size).tolist()
            slice_resol = self._get_slice_info(visu_pars)

            if dim == 3:
                spatial_resol = [voxel_resol]
                matrix_size = [matrix_size]
            elif dim == 2:
                xr, yr = voxel_resol
                xm, ym = matrix_size
                spatial_resol = [(xr, yr, zr) for zr in slice_resol[&#39;slice_distances_each_pack&#39;]]
                matrix_size   = [(xm, ym, zm) for zm in slice_resol[&#39;num_slices_each_pack&#39;]]
            else:
                raise Exception(ERROR_MESSAGES[&#39;DimSize&#39;])
            return dict(spatial_resol = spatial_resol,
                        matrix_size   = matrix_size,
                        fov_size=fov_size,
                        unit          = &#39;mm&#39;,
                        )

    def _get_slice_info(self, visu_pars):
        version = get_value(visu_pars, &#39;VisuVersion&#39;)
        fg_info = self._get_frame_group_info(visu_pars)
        num_slice_packs = None
        num_slices_each_pack = []
        slice_distances_each_pack = []

        if fg_info[&#39;frame_type&#39;] is None:
            num_slice_packs = 1
            # below will be 1 in 3D protocol
            num_slices_each_pack = [get_value(visu_pars, &#39;VisuCoreFrameCount&#39;)]
            # below will be size of slice_enc axis in 3D protocol
            slice_distances_each_pack = [get_value(visu_pars, &#39;VisuCoreFrameThickness&#39;)]
        else:
            frame_groups = fg_info[&#39;group_id&#39;]
            if version == 1: # PV 5.1 support
                try:
                    phase_enc_dir = get_value(visu_pars, &#39;VisuAcqImagePhaseEncDir&#39;)
                    phase_enc_dir = [phase_enc_dir[0]] if is_all_element_same(phase_enc_dir) else phase_enc_dir
                    num_slice_packs = len(phase_enc_dir)
                except:
                    num_slice_packs = 1
                matrix_shape = fg_info[&#39;matrix_shape&#39;]
                frame_thickness = get_value(visu_pars, &#39;VisuCoreFrameThickness&#39;)
                num_slice_frames = 0
                # for id, fg in enumerate(frame_groups):
                for _, fg in enumerate(frame_groups):
                    if re.search(&#39;slice&#39;, fg, re.IGNORECASE):
                        num_slice_frames += 1
                        if num_slice_frames &gt; 2:
                            raise Exception(ERROR_MESSAGES[&#39;SlicePacksSlices&#39;])
                        if num_slice_packs &gt; 1:
                            for s in range(num_slice_packs):
                                # num_slices_each_pack.append(int(matrix_shape[id]/num_slice_packs))
                                num_slices_each_pack.append(int(matrix_shape[0]/num_slice_packs))
                        else:
                            # num_slices_each_pack.append(matrix_shape[id])
                            num_slices_each_pack.append(matrix_shape[0])
                slice_distances_each_pack = [frame_thickness for _ in range(num_slice_packs)]
            elif version == 3:
                num_slice_packs = get_value(visu_pars, &#39;VisuCoreSlicePacksDef&#39;)
                if num_slice_packs is None:
                    num_slice_packs = 1
                    # raise Exception(ERROR_MESSAGES[&#39;NoSlicePacksDef&#39;])
                else:
                    num_slice_packs = num_slice_packs[0][1]

                slices_info_in_pack = get_value(visu_pars, &#39;VisuCoreSlicePacksSlices&#39;)
                slice_distance = get_value(visu_pars, &#39;VisuCoreSlicePacksSliceDist&#39;)
                num_slice_frames = 0
                # for id, fg in enumerate(frame_groups):
                for _, fg in enumerate(frame_groups):
                    if re.search(&#39;slice&#39;, fg, re.IGNORECASE):
                        num_slice_frames += 1
                        if num_slice_frames &gt; 2:
                            raise Exception(ERROR_MESSAGES[&#39;SlicePacksSlices&#39;])
                        try:
                            # num_slices_each_pack = [slices_info_in_pack[id][1] for _ in range(num_slice_packs)]
                            num_slices_each_pack = [slices_info_in_pack[0][1] for _ in range(num_slice_packs)]
                        except:
                            raise Exception(ERROR_MESSAGES[&#39;SlicePacksSlices&#39;])
                        if isinstance(slice_distance, list):
                            # slice_distances_each_pack = [slice_distance[id] for _ in range(num_slice_packs)]
                            slice_distances_each_pack = [slice_distance[0] for _ in range(num_slice_packs)]
                        elif isinstance(slice_distance, float) or isinstance(slice_distance, int):
                            slice_distances_each_pack = [slice_distance for _ in range(num_slice_packs)]
                        else:
                            raise Exception(ERROR_MESSAGES[&#39;SliceDistDatatype&#39;])
            if len(slice_distances_each_pack) == 0:
                slice_distances_each_pack = [get_value(visu_pars, &#39;VisuCoreFrameThickness&#39;)]
            else:
                for i, d in enumerate(slice_distances_each_pack):
                    if d == 0:
                        slice_distances_each_pack[i] = get_value(visu_pars, &#39;VisuCoreFrameThickness&#39;)
            if len(num_slices_each_pack) == 0:
                num_slices_each_pack = [1]

        return dict(num_slice_packs            = num_slice_packs,
                    num_slices_each_pack       = num_slices_each_pack,
                    slice_distances_each_pack  = slice_distances_each_pack,
                    unit_slice_distances       = &#39;mm&#39;
                    )

    def _get_orient_info(self, visu_pars, method):

        def get_axis_orient(orient_matrix):
            &#34;&#34;&#34;return indice of axis orientation profiles&#34;&#34;&#34;
            return [np.argmax(abs(orient_matrix[:, 0])),
                    np.argmax(abs(orient_matrix[:, 1])),
                    np.argmax(abs(orient_matrix[:, 2]))]

        omatrix_parser  = []
        oorder_parser   = []
        vposition_parser = []

        orient_matrix = get_value(visu_pars, &#39;VisuCoreOrientation&#39;).tolist()
        slice_info = self._get_slice_info(visu_pars)
        slice_position = get_value(visu_pars, &#39;VisuCorePosition&#39;)
        subj_position = get_value(visu_pars, &#39;VisuSubjectPosition&#39;)
        gradient_orient = get_value(method, &#39;PVM_SPackArrGradOrient&#39;)

        if slice_info[&#39;num_slice_packs&#39;] &gt; 1:
            num_ori_mat = len(orient_matrix)
            num_slice_packs = slice_info[&#39;num_slice_packs&#39;]
            if num_ori_mat != num_slice_packs:
                mpms = True
                if not num_slice_packs % num_ori_mat:
                    raise Exception(ERROR_MESSAGES[&#39;NumOrientMatrix&#39;])
                else:
                    # multi slice packs and multi slices, each slice packs must be identical on element.
                    # TODO: If error occurred it means the existing of exception for this.
                    cut_idx = 0
                    num_slices = int(num_ori_mat / num_slice_packs)
                    _orient_matrix = []
                    _slice_position = []
                    for ci in range(num_slice_packs):
                        om_set = orient_matrix[cut_idx:cut_idx + num_slices]
                        sp_set = slice_position[cut_idx:cut_idx + num_slices]
                        if is_all_element_same(om_set):
                            _orient_matrix.append(om_set[0])
                            _slice_position.append(sp_set)
                        else:
                            raise Exception(ERROR_MESSAGES[&#39;NumOrientMatrix&#39;])
                        cut_idx += num_slices
                orient_matrix = _orient_matrix
                slice_position = _slice_position
            else:
                mpms = False

            for id, _om in enumerate(orient_matrix):
                om = np.asarray(_om).reshape([3, 3])
                omatrix_parser.append(om)
                oorder_parser.append(get_axis_orient(om))
                if mpms:
                    vposition_parser.append(get_origin(slice_position[id], gradient_orient))
                else:
                    vposition_parser.append(slice_position[id])

        else:
            # check num_slices of first slice_pack
            if is_all_element_same(orient_matrix):
                orient_matrix = orient_matrix[0]
            else:
                raise Exception(ERROR_MESSAGES[&#39;NumOrientMatrix&#39;])
            try:
                slice_position = get_origin(slice_position, gradient_orient)
            except:
                raise Exception(ERROR_MESSAGES[&#39;NumSlicePosition&#39;])

            omatrix_parser = np.asarray(orient_matrix).reshape([3, 3])
            oorder_parser = get_axis_orient(omatrix_parser)
            vposition_parser = slice_position

        return dict(subject_type = get_value(visu_pars, &#39;VisuSubjectType&#39;),
                    subject_position = subj_position,
                    volume_position = vposition_parser,
                    orient_matrix = omatrix_parser,
                    orient_order  = oorder_parser,
                    gradient_orient = gradient_orient,
                    )

    def _get_affine(self, visu_pars, method):
        is_reversed = True if self._get_disk_slice_order(visu_pars) == &#39;reverse&#39; else False
        slice_info = self._get_slice_info(visu_pars)
        spatial_info = self._get_spatial_info(visu_pars)
        orient_info = self._get_orient_info(visu_pars, method)
        slice_orient_map = {0: &#39;sagital&#39;, 1: &#39;coronal&#39;, 2: &#39;axial&#39;}
        num_slice_packs = slice_info[&#39;num_slice_packs&#39;]
        subj_pose = orient_info[&#39;subject_position&#39;]
        subj_type = orient_info[&#39;subject_type&#39;]

        if num_slice_packs &gt; 1:
            affine = []
            for slice_idx in range(num_slice_packs):
                sidx = orient_info[&#39;orient_order&#39;][slice_idx].index(2)
                slice_orient = slice_orient_map[sidx]
                resol = spatial_info[&#39;spatial_resol&#39;][slice_idx]
                rmat = orient_info[&#39;orient_matrix&#39;][slice_idx]
                pose = orient_info[&#39;volume_position&#39;][slice_idx]
                if is_reversed:
                    raise UnexpectedError(&#39;Invalid VisuCoreDiskSliceOrder;&#39;
                                          &#39;The multi-slice-packs dataset reversed is not tested data.&#39;
                                          f&#39;{ISSUE_REPORT}&#39;)
                affine.append(build_affine_from_orient_info(resol, rmat, pose,
                                                            subj_pose, subj_type,
                                                            slice_orient))
        else:
            sidx = orient_info[&#39;orient_order&#39;].index(2)
            slice_orient = slice_orient_map[sidx]
            resol = spatial_info[&#39;spatial_resol&#39;][0]
            rmat = orient_info[&#39;orient_matrix&#39;]
            pose = orient_info[&#39;volume_position&#39;]
            if is_reversed:
                distance = slice_info[&#39;slice_distances_each_pack&#39;]
                pose = reversed_pose_correction(pose, rmat, distance)
            affine = build_affine_from_orient_info(resol, rmat, pose,
                                                   subj_pose, subj_type,
                                                   slice_orient)
        return affine

    def _get_matrix_size(self, visu_pars, dataobj=None):

        spatial_info        = self._get_spatial_info(visu_pars)
        slice_info          = self._get_slice_info(visu_pars)
        temporal_info       = self._get_temp_info(visu_pars)
        # patch the case of multi-echo
        fg_info             = self._get_frame_group_info(visu_pars)

        matrix_size         = spatial_info[&#39;matrix_size&#39;]
        num_temporal_frame  = temporal_info[&#39;num_frames&#39;]
        num_slice_packs     = slice_info[&#39;num_slice_packs&#39;]

        if num_slice_packs &gt; 1:
            if is_all_element_same(matrix_size):
                matrix_size         = list(matrix_size[0])
                total_num_slices    = sum(slice_info[&#39;num_slices_each_pack&#39;])
                matrix_size[-1]     = total_num_slices
            else:
                raise UnexpectedError(&#39;Matrix size mismatch with multi-slice-packs dataobj;&#39;
                                      f&#39;{matrix_size}&#39;
                                      f&#39;{ISSUE_REPORT}&#39;)
        else:
            matrix_size = list(matrix_size[0])
            if &#39;FG_SLICE&#39; in fg_info[&#39;group_id&#39;]:
                if fg_info[&#39;group_id&#39;].index(&#39;FG_SLICE&#39;):  # in the case the slicing frame group happen later
                    matrix_size     = matrix_size[:2]
                    matrix_size.extend(fg_info[&#39;matrix_shape&#39;])
                else:
                    if num_temporal_frame &gt; 1:
                        matrix_size.append(num_temporal_frame)
            else:
                if num_temporal_frame &gt; 1:
                    matrix_size.append(num_temporal_frame)

        if dataobj is not None:
            # matrix size inspection
            dataobj_shape = dataobj.shape[0]
            if multiply_all(matrix_size) != dataobj_shape:
                raise UnexpectedError(&#39;Matrix size mismatch with dataobj;&#39;
                                      f&#39;{multiply_all(matrix_size)} != {dataobj_shape}&#39;
                                      f&#39;{ISSUE_REPORT}&#39;)
        return matrix_size

    @staticmethod
    def _get_disk_slice_order(visu_pars):
        # check disk_slice_order #
        _fo = get_value(visu_pars, &#39;VisuCoreDiskSliceOrder&#39;)
        if _fo in [None, &#39;disk_normal_slice_order&#39;]:
            disk_slice_order = &#39;normal&#39;
        elif _fo == &#39;disk_reverse_slice_order&#39;:
            disk_slice_order = &#39;reverse&#39;
        else:
            raise UnexpectedError(f&#39;Invalid VisuCoreDiskSliceOrder:{_fo};&#39;
                                  f&#39;{ISSUE_REPORT}&#39;)
        return disk_slice_order

    def _get_visu_pars(self, scan_id, reco_id):
        return self._pvobj.get_visu_pars(scan_id, reco_id)

    @staticmethod
    def _get_frame_group_info(visu_pars):
        frame_group = get_value(visu_pars, &#39;VisuFGOrderDescDim&#39;)
        parser = dict(frame_type=None,
                      frame_size=0, matrix_shape=[],
                      group_id=[], group_comment=[],
                      dependent_vals=[])
        if frame_group is None:
            # there are no frame group exist
            return parser
        else:
            parser[&#39;frame_type&#39;] = get_value(visu_pars, &#39;VisuCoreFrameType&#39;)
            for idx, d in enumerate(get_value(visu_pars, &#39;VisuFGOrderDesc&#39;)):
                (num_fg_elements, fg_id, fg_commt,
                 valsStart, valsCnt) = d
                # calsCnt = Number of dependent parameters
                # valsStart = index of starting of dependent parameter (described in &#39;VisuGroupDepVals&#39;)
                # e.g. if calcCnt is 2, and valsStart is 1, parameter index will be 1, and 2
                parser[&#39;matrix_shape&#39;].append(num_fg_elements)
                parser[&#39;group_id&#39;].append(fg_id)
                parser[&#39;group_comment&#39;].append(fg_commt)
                parser[&#39;dependent_vals&#39;].append([])
                if valsCnt &gt; 0:
                    for i in range(valsCnt):
                        parser[&#39;dependent_vals&#39;][idx].append(get_value(visu_pars, &#39;VisuGroupDepVals&#39;)[valsStart + i])
            parser[&#39;frame_size&#39;] = reduce(lambda x, y: x * y, parser[&#39;matrix_shape&#39;])
            return parser

    @property
    def _subject(self):
        return self._pvobj._subject

    @property
    def _acqp(self):
        return self._pvobj._acqp

    @property
    def _method(self):
        return self._pvobj._method

    @property
    def _avail(self):
        return self._pvobj.avail_reco_id</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="brkraw.BrukerLoader.get_visu_pars"><code class="name">var <span class="ident">get_visu_pars</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def get_visu_pars(self):
    return self._get_visu_pars</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.is_pvdataset"><code class="name">var <span class="ident">is_pvdataset</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_pvdataset(self):
    return self._is_pvdataset</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.num_recos"><code class="name">var <span class="ident">num_recos</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_recos(self):
    return sum([len(r) for r in self._avail.values()])</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.num_scans"><code class="name">var <span class="ident">num_scans</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_scans(self):
    return len(self._pvobj._fid.keys())</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.pvobj"><code class="name">var <span class="ident">pvobj</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pvobj(self):
    return self._pvobj</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.save_as"><code class="name">var <span class="ident">save_as</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def save_as(self):
    return self.save_nifti</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="brkraw.BrukerLoader.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    self._pvobj.close()
    self._pvobj = None</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_acqp"><code class="name flex">
<span>def <span class="ident">get_acqp</span></span>(<span>self, scan_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_acqp(self, scan_id):
    return self._acqp[scan_id]</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_affine"><code class="name flex">
<span>def <span class="ident">get_affine</span></span>(<span>self, scan_id, reco_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_affine(self, scan_id, reco_id):
    visu_pars = self._get_visu_pars(scan_id, reco_id)
    method = self._method[scan_id]
    return self._get_affine(visu_pars, method)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_bdata"><code class="name flex">
<span>def <span class="ident">get_bdata</span></span>(<span>self, scan_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bdata(self, scan_id):
    method = self.get_method(scan_id)
    return self._get_bdata(method)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_dataobj"><code class="name flex">
<span>def <span class="ident">get_dataobj</span></span>(<span>self, scan_id, reco_id, slope=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataobj that has 3D(spatial) + extra frame</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scan_id</code></strong></dt>
<dd>scan id</dd>
<dt><strong><code>reco_id</code></strong></dt>
<dd>reco id</dd>
<dt><strong><code>slope</code></strong></dt>
<dd>if True correct slope</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dataobj</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dataobj(self, scan_id, reco_id, slope=True):
    &#34;&#34;&#34; Return dataobj that has 3D(spatial) + extra frame
    Args:
        scan_id: scan id
        reco_id: reco id
        slope: if True correct slope
    Returns:
        dataobj
    &#34;&#34;&#34;
    visu_pars   = self._get_visu_pars(scan_id, reco_id)
    dim         = self._get_dim_info(visu_pars)[0]
    fg_info     = self._get_frame_group_info(visu_pars)
    matrix_size = self.get_matrix_size(scan_id, reco_id)
    dataobj = self._get_dataobj(scan_id, reco_id)
    group_id    = fg_info[&#39;group_id&#39;]

    if slope:
        data_slp, data_off = self._get_dataslp(visu_pars)
        f = fg_info[&#39;frame_size&#39;]
        if isinstance(data_slp, list):
            if f != len(data_slp):
                raise UnexpectedError(message=&#39;data_slp mismatch;&#39;
                                              f&#39;{ISSUE_REPORT}&#39;)
            else:
                if dim == 2:
                    x, y = matrix_size[:2]
                    _dataobj = dataobj.reshape([f, x * y]).T
                elif dim == 3:
                    x, y, z = matrix_size[:3]
                    _dataobj = dataobj.reshape([f, x * y * z]).T
                else:
                    raise UnexpectedError(message=&#39;Unexpected frame shape on DTI image;&#39;
                                                  f&#39;{ISSUE_REPORT}&#39;)
            dataobj = (_dataobj * data_slp + data_off).T
        else:
            dataobj = dataobj * data_slp + data_off

    dataobj = dataobj.reshape(matrix_size[::-1]).T

    def swap_slice_axis(group_id_, dataobj_):
        &#34;&#34;&#34; swap slice axis to third axis &#34;&#34;&#34;
        slice_code = &#39;FG_SLICE&#39;
        if slice_code not in group_id_:
            pass
        else:
            slice_axis_ = group_id_.index(slice_code) + 2
            dataobj_ = np.swapaxes(dataobj_, 2, slice_axis_)
        return dataobj_

    if fg_info[&#39;frame_type&#39;] is not None:
        if group_id[0] == &#39;FG_SLICE&#39;:
            pass

        elif group_id[0] == &#39;FG_ECHO&#39;:  # multi-echo
            if self.is_multi_echo(scan_id, reco_id):
                # push echo to last axis for BIDS
                if &#39;FG_SLICE&#39; not in group_id:
                    dataobj = np.swapaxes(dataobj, dim, -1)
                else:
                    slice_axis = group_id.index(&#39;FG_SLICE&#39;) + 2
                    dataobj = np.swapaxes(dataobj, slice_axis, -1)
                    dataobj = np.swapaxes(dataobj, 2, -1)

        elif group_id[0] == &#39;FG_DIFFUSION&#39;:
            dataobj = swap_slice_axis(group_id, dataobj)

        elif group_id[0] == &#39;FG_DTI&#39;:   # reconstructed
            dataobj = swap_slice_axis(group_id, dataobj)

        elif group_id[0] == &#39;FG_MOVIE&#39;:
            dataobj = swap_slice_axis(group_id, dataobj)

        else:
            raise UnexpectedError(message=&#39;Unexpected frame group combination;&#39;
                                          f&#39;{ISSUE_REPORT}&#39;)
    return dataobj</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_fid"><code class="name flex">
<span>def <span class="ident">get_fid</span></span>(<span>self, scan_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fid(self, scan_id):
    return self._pvobj.get_fid(scan_id)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_matrix_size"><code class="name flex">
<span>def <span class="ident">get_matrix_size</span></span>(<span>self, scan_id, reco_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_matrix_size(self, scan_id, reco_id):
    visu_pars = self._get_visu_pars(scan_id, reco_id)
    dataobj = self._get_dataobj(scan_id, reco_id)
    return self._get_matrix_size(visu_pars, dataobj)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_method"><code class="name flex">
<span>def <span class="ident">get_method</span></span>(<span>self, scan_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_method(self, scan_id):
    return self._method[scan_id]</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_niftiobj"><code class="name flex">
<span>def <span class="ident">get_niftiobj</span></span>(<span>self, scan_id, reco_id, crop=None, slope=False)</span>
</code></dt>
<dd>
<div class="desc"><p>return nibabel nifti object</p>
<h2 id="args">Args</h2>
<dl>
<dt>scan_id:</dt>
<dt>reco_id:</dt>
<dt><strong><code>crop</code></strong></dt>
<dd>frame crop range</dd>
<dt><strong><code>slope</code></strong></dt>
<dd>if True, slope correction, else, header update</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nibabel.Nifti1Image</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_niftiobj(self, scan_id, reco_id, crop=None, slope=False):
    &#34;&#34;&#34; return nibabel nifti object
    Args:
        scan_id:
        reco_id:
        crop:   frame crop range
        slope:  if True, slope correction, else, header update
    Returns:
        nibabel.Nifti1Image
    &#34;&#34;&#34;
    from nibabel import Nifti1Image
    visu_pars = self._get_visu_pars(scan_id, reco_id)
    method = self._method[scan_id]
    affine = self._get_affine(visu_pars, method)
    group_id = self._get_frame_group_info(visu_pars)[&#39;group_id&#39;]
    if &#39;FG_DTI&#39; in group_id:
        # DTI dataset has vector slope
        slope = True
    imgobj = self.get_dataobj(scan_id, reco_id, slope=slope)
    # dataobj = self._get_dataobj(scan_id, reco_id)
    # shape = self._get_matrix_size(visu_pars, dataobj)
    # imgobj = dataobj.reshape(shape[::-1]).T

    if isinstance(affine, list):
        parser = []
        slice_info = self._get_slice_info(visu_pars)
        num_slice_packs = slice_info[&#39;num_slice_packs&#39;]

        for spack_idx in range(num_slice_packs):
            num_slices_each_pack = slice_info[&#39;num_slices_each_pack&#39;]
            start = int(spack_idx * num_slices_each_pack[spack_idx])
            end = start + num_slices_each_pack[spack_idx]
            seg_imgobj = imgobj[..., start:end]
            niiobj = Nifti1Image(seg_imgobj, np.round(affine[spack_idx], decimals=3))
            niiobj = self._set_nifti_header(niiobj, visu_pars, method, slope=slope)
            parser.append(niiobj)
        return parser
    affine = np.round(affine, decimals=3)
    if self.is_multi_echo(scan_id, reco_id):
        # multi-echo image must be splitted
        parser = []
        for e in range(imgobj.shape[-1]):
            imgobj_ = imgobj[..., e]
            if len(imgobj_.shape) &gt; 4:
                x, y, z = imgobj_.shape[:3]
                f = multiply_all(imgobj_.shape[3:])
                # all converted nifti must be 4D
                imgobj_ = imgobj_.reshape([x, y, z, f])
            if crop is not None:
                if crop[0] is None:
                    niiobj_ = Nifti1Image(imgobj_[..., :crop[1]], affine)
                elif crop[1] is None:
                    niiobj_ = Nifti1Image(imgobj_[..., crop[0]:], affine)
                else:
                    niiobj_ = Nifti1Image(imgobj_[..., crop[0]:crop[1]], affine)
            else:
                niiobj_ = Nifti1Image(imgobj_, affine)
            niiobj_ = self._set_nifti_header(niiobj_, visu_pars, method, slope=slope)
            parser.append(niiobj_)
        return parser
    else:
        if len(imgobj.shape) &gt; 4:
            x, y, z = imgobj.shape[:3]
            f = multiply_all(imgobj.shape[3:])
            # all converted nifti must be 4D
            imgobj = imgobj.reshape([x, y, z, f])
    if crop is not None:
        if crop[0] is None:
            niiobj = Nifti1Image(imgobj[..., :crop[1]], affine)
        elif crop[1] is None:
            niiobj = Nifti1Image(imgobj[..., crop[0]:], affine)
        else:
            niiobj = Nifti1Image(imgobj[..., crop[0]:crop[1]], affine)
    else:
        niiobj = Nifti1Image(imgobj, affine)
    niiobj = self._set_nifti_header(niiobj, visu_pars, method, slope=slope)
    return niiobj</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_scan_time"><code class="name flex">
<span>def <span class="ident">get_scan_time</span></span>(<span>self, visu_pars=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scan_time(self, visu_pars=None):
    import datetime as dt
    subject_date = get_value(self._subject, &#39;SUBJECT_date&#39;)
    subject_date = subject_date[0] if isinstance(subject_date, list) else subject_date
    pattern_1 = r&#39;(\d{2}:\d{2}:\d{2})\s+(\d+\s\w+\s\d{4})&#39;
    pattern_2 = r&#39;(\d{4}-\d{2}-\d{2})[T](\d{2}:\d{2}:\d{2})&#39;
    if re.match(pattern_1, subject_date):
        # start time
        start_time = dt.time(*map(int, re.sub(pattern_1, r&#39;\1&#39;, subject_date).split(&#39;:&#39;)))
        # date
        date = dt.datetime.strptime(re.sub(pattern_1, r&#39;\2&#39;, subject_date), &#39;%d %b %Y&#39;).date()
        # end time
        if visu_pars is not None:
            last_scan_time = get_value(visu_pars, &#39;VisuAcqDate&#39;)
            last_scan_time = dt.time(*map(int, re.sub(pattern_1, r&#39;\1&#39;, last_scan_time).split(&#39;:&#39;)))
            acq_time = get_value(visu_pars, &#39;VisuAcqScanTime&#39;) / 1000.0
            time_delta = dt.timedelta(0, acq_time)
            scan_time = (dt.datetime.combine(date, last_scan_time) + time_delta).time()
            return dict(date=date,
                        start_time=start_time,
                        scan_time=scan_time)
    elif re.match(pattern_2, subject_date):
        # start time
        # subject_date = get_value(self._subject, &#39;SUBJECT_date&#39;)[0]
        start_time = dt.time(*map(int, re.sub(pattern_2, r&#39;\2&#39;, subject_date).split(&#39;:&#39;)))
        # date
        date = dt.date(*map(int, re.sub(pattern_2, r&#39;\1&#39;, subject_date).split(&#39;-&#39;)))

        # end date
        if visu_pars is not None:
            scan_time = get_value(visu_pars, &#39;VisuCreationDate&#39;)[0]
            scan_time = dt.time(*map(int, re.sub(pattern_2, r&#39;\2&#39;, scan_time).split(&#39;:&#39;)))
            return dict(date=date,
                        start_time=start_time,
                        scan_time=scan_time)
    else:
        raise Exception(ERROR_MESSAGES[&#39;NotIntegrated&#39;])

    return dict(date=date,
                start_time=start_time)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.get_sitkimg"><code class="name flex">
<span>def <span class="ident">get_sitkimg</span></span>(<span>self, scan_id, reco_id, slope=True, is_vector=False)</span>
</code></dt>
<dd>
<div class="desc"><p>return SimpleITK image obejct instead Nibabel NIFTI obj</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sitkimg(self, scan_id, reco_id, slope=True, is_vector=False):
    &#34;&#34;&#34; return SimpleITK image obejct instead Nibabel NIFTI obj&#34;&#34;&#34;
    import SimpleITK as sitk

    visu_pars = self._get_visu_pars(scan_id, reco_id)
    method = self._method[scan_id]
    res = self._get_spatial_info(visu_pars)[&#39;spatial_resol&#39;]
    dataobj = self.get_dataobj(scan_id, reco_id, slope=slope)
    affine = self._get_affine(visu_pars, method)

    if isinstance(affine, list):
        parser = []
        slice_info = self._get_slice_info(visu_pars)
        num_slice_packs = slice_info[&#39;num_slice_packs&#39;]
        for spack_idx in range(num_slice_packs):
            num_slices_each_pack = slice_info[&#39;num_slices_each_pack&#39;]
            start = int(spack_idx * num_slices_each_pack[spack_idx])
            end = start + num_slices_each_pack[spack_idx]
            seg_imgobj = dataobj[..., start:end]
            sitkobj = sitk.GetImageFromArray(seg_imgobj.T)
            sitkaff = np.matmul(np.diag([-1, -1, 1, 1]), affine[spack_idx])
            sitkdir, sitkorg = to_matvec(sitkaff)
            sitkdir = sitkdir.dot(np.linalg.inv(np.diag(res[spack_idx])))
            sitkobj.SetDirection(sitkdir.flatten().tolist())
            sitkobj.SetOrigin(sitkorg)
            sitkobj.SetSpacing(res[spack_idx])
            parser.append(sitkobj)
        return parser

    affine = np.matmul(np.diag([-1, -1, 1, 1]), affine)  # RAS to LPS
    direction_, origin_ = to_matvec(affine)
    direction_ = direction_.dot(np.linalg.inv(np.diag(res[0])))
    imgobj = sitk.GetImageFromArray(dataobj.T, isVector=is_vector)

    if len(dataobj.shape) &gt; 3:
        res = [list(res[0]) + [self._get_temp_info(visu_pars)[&#39;temporal_resol&#39;]]]
        direction = np.eye(4)
        direction[:3, :3] = direction_
        direction = direction.flatten()
        origin = np.zeros([4])
        origin[:3] = origin_
    else:
        direction = direction_
        origin = origin_
    imgobj.SetDirection(direction.flatten().tolist())
    imgobj.SetOrigin(origin)
    imgobj.SetSpacing(res[0])
    # header update
    imgobj = self._set_dicom_header(imgobj, visu_pars, method, slope)
    return imgobj</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, io_handler=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints out the information of the internal contents in Bruker raw data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>io_handler</code></strong></dt>
<dd>IO handler where to print out</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, io_handler=None):
    &#34;&#34;&#34; Prints out the information of the internal contents in Bruker raw data
    Args:
        io_handler: IO handler where to print out
    &#34;&#34;&#34;
    if io_handler == None:
        import sys
        io_handler = sys.stdout

    pvobj = self._pvobj
    user_account = pvobj.user_account
    subj_id = pvobj.subj_id
    study_id = pvobj.study_id
    session_id = pvobj.session_id
    user_name = pvobj.user_name
    subj_entry = pvobj.subj_entry
    subj_pose = pvobj.subj_pose
    subj_sex = pvobj.subj_sex
    subj_type = pvobj.subj_type
    subj_weight = pvobj.subj_weight
    subj_dob = pvobj.subj_dob

    lines = []
    for i, (scan_id, recos) in enumerate(self._avail.items()):
        for j, reco_id in enumerate(recos):
            visu_pars = self._get_visu_pars(scan_id, reco_id)
            if i == 0:
                sw_version = get_value(visu_pars, &#39;VisuCreatorVersion&#39;)

                title = &#39;Paravision {}&#39;.format(sw_version)
                lines.append(title)
                lines.append(&#39;-&#39; * len(title))

                try:
                    datetime = self.get_scan_time()
                except:
                    datetime = dict(date=&#39;None&#39;)
                    # raise Exception(&#39;Empty dataset...&#39;)
                lines.append(&#39;UserAccount:\t{}&#39;.format(user_account))
                lines.append(&#39;Date:\t\t{}&#39;.format(datetime[&#39;date&#39;]))
                lines.append(&#39;Researcher:\t{}&#39;.format(user_name))
                lines.append(&#39;Subject ID:\t{}&#39;.format(subj_id))
                lines.append(&#39;Session ID:\t{}&#39;.format(session_id))
                lines.append(&#39;Study ID:\t{}&#39;.format(study_id))
                lines.append(&#39;Date of Birth:\t{}&#39;.format(subj_dob))
                lines.append(&#39;Sex:\t\t{}&#39;.format(subj_sex))
                lines.append(&#39;Weight:\t\t{} kg&#39;.format(subj_weight))
                lines.append(&#39;Subject Type:\t{}&#39;.format(subj_type))
                lines.append(&#39;Position:\t{}\t\tEntry:\t{}&#39;.format(subj_pose, subj_entry))

                lines.append(&#39;\n[ScanID]\tSequence::Protocol::[Parameters]&#39;)
            # try:
            tr = get_value(visu_pars, &#39;VisuAcqRepetitionTime&#39;)
            tr = &#39;,&#39;.join(map(str, tr)) if isinstance(tr, list) else tr
            te = get_value(visu_pars, &#39;VisuAcqEchoTime&#39;)
            te = 0 if te is None else te
            te = &#39;,&#39;.join(map(str, te)) if isinstance(te, list) else te
            pixel_bw = get_value(visu_pars, &#39;VisuAcqPixelBandwidth&#39;)
            flip_angle = get_value(visu_pars, &#39;VisuAcqFlipAngle&#39;)
            param_values = [tr, te, pixel_bw, flip_angle]
            for k, v in enumerate(param_values):
                if v is None:
                    param_values[k] = &#39;&#39;
                if isinstance(v, float):
                    param_values[k] = &#39;{0:.2f}&#39;.format(v)
            if j == 0:
                params = &#34;[ TR: {0} ms, TE: {1} ms, pixelBW: {2} Hz, FlipAngle: {3} degree]&#34;.format(
                    *param_values)
                protocol_name = get_value(visu_pars, &#39;VisuAcquisitionProtocol&#39;)
                sequence_name = get_value(visu_pars, &#39;VisuAcqSequenceName&#39;)
                lines.append(&#39;[{}]\t{}::{}::\n\t{}&#39;.format(str(scan_id).zfill(3),
                                                           sequence_name,
                                                           protocol_name,
                                                           params))

            dim, cls = self._get_dim_info(visu_pars)
            if cls == &#39;spatial_only&#39;:
                size = self._get_matrix_size(visu_pars)
                size = &#39; x &#39;.join(map(str, size))
                spatial_info = self._get_spatial_info(visu_pars)
                temp_info = self._get_temp_info(visu_pars)
                s_resol = spatial_info[&#39;spatial_resol&#39;]
                fov_size = spatial_info[&#39;fov_size&#39;]
                fov_size = &#39; x &#39;.join(map(str, fov_size))
                s_unit = spatial_info[&#39;unit&#39;]
                t_resol = &#39;{0:.3f}&#39;.format(temp_info[&#39;temporal_resol&#39;])
                t_unit = temp_info[&#39;unit&#39;]
                s_resol = list(s_resol[0]) if is_all_element_same(s_resol) else s_resol
                s_resol = &#39; x &#39;.join([&#39;{0:.3f}&#39;.format(r) for r in s_resol])

                lines.append(&#39;    [{}] dim: {}D, matrix_size: {}, fov_size: {} (unit:mm)\n&#39;
                             &#39;         spatial_resol: {} (unit:{}), temporal_resol: {} (unit:{})&#39;.format(
                    str(reco_id).zfill(2), dim, size,
                    fov_size,
                    s_resol, s_unit,
                    t_resol, t_unit))
            else:
                lines.append(f&#39;    [{str(reco_id).zfill(2)}] dim: {dim}, {cls}&#39;)
            # except Exception as e:
            #     print(e)
            #     print(f&#39;Issue found at {scan_id}&#39;)
    lines.append(&#39;\n&#39;)
    print(&#39;\n&#39;.join(lines), file=io_handler)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.is_multi_echo"><code class="name flex">
<span>def <span class="ident">is_multi_echo</span></span>(<span>self, scan_id, reco_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_multi_echo(self, scan_id, reco_id):
    visu_pars = self._get_visu_pars(scan_id, reco_id)
    fg_info = self._get_frame_group_info(visu_pars)
    group_id = fg_info[&#39;group_id&#39;]
    if &#39;FG_ECHO&#39; in group_id and &#39;FieldMap&#39; not in fg_info[&#39;group_comment&#39;]:  #FieldMap will be treated different
        return fg_info[&#39;matrix_shape&#39;][group_id.index(&#39;FG_ECHO&#39;)]  # return number of echos
    else:
        return False</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.print_bids"><code class="name flex">
<span>def <span class="ident">print_bids</span></span>(<span>self, scan_id, reco_id, fobj=None, metadata=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_bids(self, scan_id, reco_id, fobj=None, metadata=None):
    if fobj == None:
        import sys
        fobj = sys.stdout
    json_obj = self._parse_json(scan_id, reco_id, metadata)
    for k, val in json_obj.items():
        n_tap = int(5 - int(len(k) / 8))
        if len(k) % 8 &gt;= 7:
            n_tap -= 1
        tap = &#39;&#39;.join([&#39;\t&#39;] * n_tap)
        print(&#39;{}:{}{}&#39;.format(k, tap, val), file=fobj)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.save_bdata"><code class="name flex">
<span>def <span class="ident">save_bdata</span></span>(<span>self, scan_id, filename, dir='./')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_bdata(self, scan_id, filename, dir=&#39;./&#39;):
    method = self._method[scan_id]
    bval, bvec, bmat = self._get_bdata(method)
    output_path = os.path.join(dir, filename)

    with open(&#39;{}.bval&#39;.format(output_path), &#39;w&#39;) as bval_fobj:
        for item in bval:
            bval_fobj.write(&#34;%f &#34; % item)
        bval_fobj.write(&#34;\n&#34;)

    with open(&#39;{}.bvec&#39;.format(output_path), &#39;w&#39;) as bvec_fobj:
        for row in bvec:
            for item in row:
                bvec_fobj.write(&#34;%f &#34; % item)
            bvec_fobj.write(&#34;\n&#34;)

    with open(&#39;{}.bmat&#39;.format(output_path), &#39;w&#39;) as bmat_fobj:
        for row in bmat:
            for item in row.flatten():
                bmat_fobj.write(&#34;%s &#34; % item)
            bmat_fobj.write(&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.save_json"><code class="name flex">
<span>def <span class="ident">save_json</span></span>(<span>self, scan_id, reco_id, filename, dir='./', metadata=None, condition=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_json(self, scan_id, reco_id, filename, dir=&#39;./&#39;, metadata=None, condition=None):
    json_obj = self._parse_json(scan_id, reco_id, metadata)
    if condition is not None:
        code, idx = condition
        if code == &#39;me&#39;:    # multi-echo
            if &#39;EchoTime&#39; in json_obj.keys():
                te = json_obj[&#39;EchoTime&#39;]
                if isinstance(te, list):
                    json_obj[&#39;EchoTime&#39;] = te[idx]
                else:
                    raise InvalidApproach(&#39;SingleTE data&#39;)
        elif code == &#39;fm&#39;:
            visu_pars = self._get_visu_pars(scan_id, reco_id)
            json_obj[&#39;Units&#39;] = get_value(visu_pars, &#39;VisuCoreDataUnits&#39;)[0]
            json_obj[&#39;IntendFor&#39;] = [&#34;func/*_bold.nii.gz&#34;]
        else:
            raise InvalidApproach(&#39;Invalid datatype code for json creation&#39;)

    # remove all null fields
    for k, v in json_obj.items():
        if v is None:
            json_obj[k] = &#39;Value was not specified&#39;
    with open(os.path.join(dir, &#39;{}.json&#39;.format(filename)), &#39;w&#39;) as f:
        import json
        json.dump(json_obj, f, indent=4)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.save_nifti"><code class="name flex">
<span>def <span class="ident">save_nifti</span></span>(<span>self, scan_id, reco_id, filename, dir='./', ext='nii.gz', crop=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_nifti(self, scan_id, reco_id, filename, dir=&#39;./&#39;, ext=&#39;nii.gz&#39;,
            crop=None):
    niiobj = self.get_niftiobj(scan_id, reco_id, crop=crop)
    if isinstance(niiobj, list):
        for i, nii in enumerate(niiobj):
            output_path = os.path.join(dir,
                                       &#39;{}-{}.{}&#39;.format(filename,
                                                         str(i+1).zfill(2), ext))
            nii.to_filename(output_path)
    else:
        output_path = os.path.join(dir, &#39;{}.{}&#39;.format(filename, ext))
        niiobj.to_filename(output_path)</code></pre>
</details>
</dd>
<dt id="brkraw.BrukerLoader.save_sitk"><code class="name flex">
<span>def <span class="ident">save_sitk</span></span>(<span>self, io_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: mha, nrrd format with header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_sitk(self, io_type=None):
    &#34;&#34;&#34; TODO: mha, nrrd format with header &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="brkraw.lib" href="lib/index.html">brkraw.lib</a></code></li>
<li><code><a title="brkraw.scripts" href="scripts/index.html">brkraw.scripts</a></code></li>
<li><code><a title="brkraw.ui" href="ui/index.html">brkraw.ui</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="brkraw.BrukerLoader" href="#brkraw.BrukerLoader">BrukerLoader</a></code></h4>
<ul class="two-column">
<li><code><a title="brkraw.BrukerLoader.close" href="#brkraw.BrukerLoader.close">close</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_acqp" href="#brkraw.BrukerLoader.get_acqp">get_acqp</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_affine" href="#brkraw.BrukerLoader.get_affine">get_affine</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_bdata" href="#brkraw.BrukerLoader.get_bdata">get_bdata</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_dataobj" href="#brkraw.BrukerLoader.get_dataobj">get_dataobj</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_fid" href="#brkraw.BrukerLoader.get_fid">get_fid</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_matrix_size" href="#brkraw.BrukerLoader.get_matrix_size">get_matrix_size</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_method" href="#brkraw.BrukerLoader.get_method">get_method</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_niftiobj" href="#brkraw.BrukerLoader.get_niftiobj">get_niftiobj</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_scan_time" href="#brkraw.BrukerLoader.get_scan_time">get_scan_time</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_sitkimg" href="#brkraw.BrukerLoader.get_sitkimg">get_sitkimg</a></code></li>
<li><code><a title="brkraw.BrukerLoader.get_visu_pars" href="#brkraw.BrukerLoader.get_visu_pars">get_visu_pars</a></code></li>
<li><code><a title="brkraw.BrukerLoader.info" href="#brkraw.BrukerLoader.info">info</a></code></li>
<li><code><a title="brkraw.BrukerLoader.is_multi_echo" href="#brkraw.BrukerLoader.is_multi_echo">is_multi_echo</a></code></li>
<li><code><a title="brkraw.BrukerLoader.is_pvdataset" href="#brkraw.BrukerLoader.is_pvdataset">is_pvdataset</a></code></li>
<li><code><a title="brkraw.BrukerLoader.num_recos" href="#brkraw.BrukerLoader.num_recos">num_recos</a></code></li>
<li><code><a title="brkraw.BrukerLoader.num_scans" href="#brkraw.BrukerLoader.num_scans">num_scans</a></code></li>
<li><code><a title="brkraw.BrukerLoader.print_bids" href="#brkraw.BrukerLoader.print_bids">print_bids</a></code></li>
<li><code><a title="brkraw.BrukerLoader.pvobj" href="#brkraw.BrukerLoader.pvobj">pvobj</a></code></li>
<li><code><a title="brkraw.BrukerLoader.save_as" href="#brkraw.BrukerLoader.save_as">save_as</a></code></li>
<li><code><a title="brkraw.BrukerLoader.save_bdata" href="#brkraw.BrukerLoader.save_bdata">save_bdata</a></code></li>
<li><code><a title="brkraw.BrukerLoader.save_json" href="#brkraw.BrukerLoader.save_json">save_json</a></code></li>
<li><code><a title="brkraw.BrukerLoader.save_nifti" href="#brkraw.BrukerLoader.save_nifti">save_nifti</a></code></li>
<li><code><a title="brkraw.BrukerLoader.save_sitk" href="#brkraw.BrukerLoader.save_sitk">save_sitk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>